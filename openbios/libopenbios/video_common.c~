/*
 *   Creation Date: <2002/10/23 20:26:40 samuel>
 *   Time-stamp: <2004/01/07 19:39:15 samuel>
 *
 *     <video_common.c>
 *
 *     Shared video routines
 *
 *   Copyright (C) 2002, 2003, 2004 Samuel Rydh (samuel@ibrium.se)
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License
 *   as published by the Free Software Foundation
 *
 */

#include "config.h"
#include "libc/vsprintf.h"
#include "libopenbios/bindings.h"
#include "libopenbios/fontdata.h"
#include "libopenbios/ofmem.h"
#include "libopenbios/video.h"
#include "packages/video.h"
#include "drivers/vga.h"
#define NO_QEMU_PROTOS
#include "arch/common/fw_cfg.h"

struct video_info video;

unsigned long
video_get_color( int col_ind )
{
	unsigned long col;
	if( !VIDEO_DICT_VALUE(video.ih) || col_ind < 0 || col_ind > 255 )
		return 0;
	if( VIDEO_DICT_VALUE(video.depth) == 8 )
		return col_ind;
	col = video.pal[col_ind];
	if( VIDEO_DICT_VALUE(video.depth) == 24 || VIDEO_DICT_VALUE(video.depth) == 32 )
		return col;
	if( VIDEO_DICT_VALUE(video.depth) == 15 )
		return ((col>>9) & 0x7c00) | ((col>>6) & 0x03e0) | ((col>>3) & 0x1f);
	return 0;
}

/* ( fbaddr maskaddr width height fgcolor bgcolor -- ) */

void
video_mask_blit(void)
{
	ucell bgcolor = POP();
	ucell fgcolor = POP();
	ucell height = POP();
	ucell width = POP();
	unsigned char *mask = (unsigned char *)POP();
	unsigned char *fbaddr = (unsigned char *)POP();

	ucell color;
	unsigned char *dst, *rowdst;
	int x, y, m, b, d, depthbytes;

	fgcolor = video_get_color(fgcolor);
	bgcolor = video_get_color(bgcolor);
	d = VIDEO_DICT_VALUE(video.depth);
	depthbytes = (d + 1) >> 3;

	dst = fbaddr;
	for( y = 0; y < height; y++) {
		rowdst = dst;
		for( x = 0; x < (width + 1) >> 3; x++ ) {
			for (b = 0; b < 8; b++) {
				m = (1 << (7 - b));

				if (*mask & m) {
					color = fgcolor;
				} else {
					color = bgcolor;
				}

				if( d >= 24 )
					*((uint32_t*)dst) = color;
				else if( d >= 15 )
					*((uint16_t*)dst) = color;
				else
					*dst = color;

				dst += depthbytes;
			}
			mask++;
		}
		dst = rowdst;
		dst += VIDEO_DICT_VALUE(video.rb);
	}
}

/* ( x y w h fgcolor bgcolor -- ) */

void
video_invert_rect( void )
{
	ucell bgcolor = POP();
	ucell fgcolor = POP();
	int h = POP();
	int w = POP();
	int y = POP();
	int x = POP();
	char *pp;

	bgcolor = video_get_color(bgcolor);
	fgcolor = video_get_color(fgcolor);

	if (!VIDEO_DICT_VALUE(video.ih) || x < 0 || y < 0 || w <= 0 || h <= 0 ||
		x + w > VIDEO_DICT_VALUE(video.w) || y + h > VIDEO_DICT_VALUE(video.h))
		return;

	pp = (char*)VIDEO_DICT_VALUE(video.mvirt) + VIDEO_DICT_VALUE(video.rb) * y;
	for( ; h--; pp += *(video.rb) ) {
		int ww = w;
		if( VIDEO_DICT_VALUE(video.depth) == 24 || VIDEO_DICT_VALUE(video.depth) == 32 ) {
			uint32_t *p = (uint32_t*)pp + x;
			while( ww-- ) {
				if (*p == fgcolor) {
					*p++ = bgcolor;
				} else if (*p == bgcolor) {
					*p++ = fgcolor;
				}
			}
		} else if( VIDEO_DICT_VALUE(video.depth) == 16 || VIDEO_DICT_VALUE(video.depth) == 15 ) {
			uint16_t *p = (uint16_t*)pp + x;
			while( ww-- ) {
				if (*p == (uint16_t)fgcolor) {
					*p++ = bgcolor;
				} else if (*p == (uint16_t)bgcolor) {
					*p++ = fgcolor;
				}
			}
		} else {
			char *p = (char *)(pp + x);

			while( ww-- ) {
				if (*p == (char)fgcolor) {
					*p++ = bgcolor;
				} else if (*p == (char)bgcolor) {
					*p++ = fgcolor;
				}
			}
		}
	}
}

/* ( color_ind x y width height -- ) (?) */
void
video_fill_rect(void)
{
	int h = POP();
	int w = POP();
	int y = POP();
	int x = POP();
	int col_ind = POP();

	char *pp;
	unsigned long col = video_get_color(col_ind);

        if (!VIDEO_DICT_VALUE(video.ih) || x < 0 || y < 0 || w <= 0 || h <= 0 ||
            x + w > VIDEO_DICT_VALUE(video.w) || y + h > VIDEO_DICT_VALUE(video.h))
		return;

	pp = (char*)VIDEO_DICT_VALUE(video.mvirt) + VIDEO_DICT_VALUE(video.rb) * y;
	for( ; h--; pp += VIDEO_DICT_VALUE(video.rb) ) {
		int ww = w;
		if( VIDEO_DICT_VALUE(video.depth) == 24 || VIDEO_DICT_VALUE(video.depth) == 32 ) {
			uint32_t *p = (uint32_t*)pp + x;
			while( ww-- )
				*p++ = col;
		} else if( VIDEO_DICT_VALUE(video.depth) == 16 || VIDEO_DICT_VALUE(video.depth) == 15 ) {
			uint16_t *p = (uint16_t*)pp + x;
			while( ww-- )
				*p++ = col;
		} else {
                        char *p = (char *)(pp + x);

			while( ww-- )
				*p++ = col;
		}
	}
}

void setup_video()
{
	/* Make everything inside the video_info structure point to the
	   values in the Forth dictionary. Hence everything is always in
	   sync. */
	phandle_t options;
	char buf[6];

	feval("['] display-ih cell+");
	video.ih = cell2pointer(POP());

	feval("['] frame-buffer-adr cell+");
	video.mvirt = cell2pointer(POP());
	feval("['] openbios-video-width cell+");
	video.w = cell2pointer(POP());
	feval("['] openbios-video-height cell+");
	video.h = cell2pointer(POP());
	feval("['] depth-bits cell+");
	video.depth = cell2pointer(POP());
	feval("['] line-bytes cell+");
	video.rb = cell2pointer(POP());
	feval("['] color-palette cell+");
	video.pal = cell2pointer(POP());

	/* Set global variables ready for fb8-install */
	PUSH( pointer2cell(video_mask_blit) );
	fword("is-noname-cfunc");
	feval("to fb8-blitmask");
	PUSH( pointer2cell(video_fill_rect) );
	fword("is-noname-cfunc");
	feval("to fb8-fillrect");
	PUSH( pointer2cell(video_invert_rect) );
	fword("is-noname-cfunc");
	feval("to fb8-invertrect");

	/* Static information */
	PUSH((ucell)fontdata);
	feval("to (romfont)");
	PUSH(FONT_HEIGHT);
	feval("to (romfont-height)");
	PUSH(FONT_WIDTH);
	feval("to (romfont-width)");

	/* Initialise the structure */
	VIDEO_DICT_VALUE(video.w) = VGA_DEFAULT_WIDTH;
	VIDEO_DICT_VALUE(video.h) = VGA_DEFAULT_HEIGHT;
	VIDEO_DICT_VALUE(video.depth) = VGA_DEFAULT_DEPTH;
	VIDEO_DICT_VALUE(video.rb) = VGA_DEFAULT_LINEBYTES;
#ifndef CONFIG_TACUS
#if defined(CONFIG_QEMU) && (defined(CONFIG_PPC) || defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64))
	/* If running from QEMU, grab the parameters from the firmware interface */
	int w, h, d;

	w = fw_cfg_read_i16(FW_CFG_ARCH_WIDTH);
        h = fw_cfg_read_i16(FW_CFG_ARCH_HEIGHT);
        d = fw_cfg_read_i16(FW_CFG_ARCH_DEPTH);
	if (w && h && d) {
		VIDEO_DICT_VALUE(video.w) = w;
		VIDEO_DICT_VALUE(video.h) = h;
		VIDEO_DICT_VALUE(video.depth) = d;
		VIDEO_DICT_VALUE(video.rb) = (w * ((d + 7) / 8));
	}
#endif
#endif
#if defined(CONFIG_TACUS)
		VIDEO_DICT_VALUE(video.w) = 1024;
		VIDEO_DICT_VALUE(video.h) = 768;
		VIDEO_DICT_VALUE(video.depth) = 8;
		VIDEO_DICT_VALUE(video.rb) = 1024;
#endif

	/* Setup screen-#rows/screen-#columns */
	options = find_dev("/options");
	snprintf(buf, sizeof(buf), FMT_ucell, VIDEO_DICT_VALUE(video.w) / FONT_WIDTH);
	set_property(options, "screen-#columns", buf, strlen(buf) + 1);
	snprintf(buf, sizeof(buf), FMT_ucell, VIDEO_DICT_VALUE(video.h) / FONT_HEIGHT);
	set_property(options, "screen-#rows", buf, strlen(buf) + 1);
}


#if defined(CONFIG_TACUS)

#define BIF(x,y,z) ((x>>z)&((1<<(y-z+1))-1))
#define BIK(x,y) BIF(x,y,y)

extern volatile unsigned int *aux_reg;
volatile unsigned int *aux_iic;

static volatile int t;

static void delay(unsigned int usecs)
{
    int i;
    for (i=0;i<usecs*1000;i++) t=i;
}
 
static inline void dvi_i2c_w(int scl,int sda)
{
    delay(10);
    *aux_iic=(*aux_iic & 0xFFFFFFF8) + (scl&1) + (sda&1) * 2;
}

static inline unsigned dvi_i2c_r(void)
{
    delay(10);
    return ((*aux_iic)&4)>>2;
}

static inline void dvi_i2c_wreg(unsigned a,unsigned r,unsigned v)
{
    int i;
    // START 
    dvi_i2c_w(1,1);
    dvi_i2c_w(1,0);
    dvi_i2c_w(0,0);
    // Adresse composant
    for (i=6;i>=0;i--) {
        dvi_i2c_w(0,BIK(a,i));
        dvi_i2c_w(1,BIK(a,i));
        dvi_i2c_w(0,BIK(a,i));
    }
    // Write
    dvi_i2c_w(0,0);
    dvi_i2c_w(1,0);
    dvi_i2c_w(0,0);
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1);
    // REGISTRE
    for (i=7;i>=0;i--) {
        dvi_i2c_w(0,BIK(r,i));
        dvi_i2c_w(1,BIK(r,i));
        dvi_i2c_w(0,BIK(r,i));
    }
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1); 
     // DATA
    for (i=7;i>=0;i--) {
        dvi_i2c_w(0,BIK(v,i));
        dvi_i2c_w(1,BIK(v,i));
        dvi_i2c_w(0,BIK(v,i));
    }
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1); 
    // STOP
    dvi_i2c_w(0,0);
    dvi_i2c_w(1,0);
    dvi_i2c_w(1,1);
}

static inline unsigned dvi_i2c_rreg(unsigned a,unsigned r)
{
    int i;
    unsigned v=0;
    // START
    dvi_i2c_w(1,1);
    dvi_i2c_w(1,0);
    dvi_i2c_w(0,0);
    // Adresse
    for (i=6; i>=0; i--) {
        dvi_i2c_w(0,BIK(a,i));
        dvi_i2c_w(1,BIK(a,i));
        dvi_i2c_w(0,BIK(a,i));
    }
    // Write
    dvi_i2c_w(0,0);
    dvi_i2c_w(1,0);
    dvi_i2c_w(0,0);
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1);
    // REGISTRE
    for (i=7; i>=0; i--) {
        dvi_i2c_w(0,BIK(r,i));
        dvi_i2c_w(1,BIK(r,i));
        dvi_i2c_w(0,BIK(r,i));
    }
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1); 
    // RESTART
    dvi_i2c_w(0,0);
    dvi_i2c_w(0,1); 
    dvi_i2c_w(1,1);
    dvi_i2c_w(1,0);
    dvi_i2c_w(0,0);
    // Adresse
    for (i=6; i>=0; i--) {
        dvi_i2c_w(0,BIK(a,i));
        dvi_i2c_w(1,BIK(a,i));
        dvi_i2c_w(0,BIK(a,i));
    }
    // Read
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1);
    // ACK
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1);
 
    // DATA
    for (i=7; i>=0; i--) {
         dvi_i2c_w(0,1);
         dvi_i2c_w(1,1);
         v=v*2+dvi_i2c_r();
         dvi_i2c_w(0,1);
    }
    // ACK bit
    dvi_i2c_w(0,1);
    dvi_i2c_w(1,1);
    dvi_i2c_w(0,1); 
    // STOP
    dvi_i2c_w(0,0);
    dvi_i2c_w(1,0);
    dvi_i2c_w(1,1);
    return v;
}

void init_dvi(unsigned video_type)
{
//    int i,j,k,r,g,b;
    aux_iic=aux_reg + 1;
 
    dvi_i2c_wreg(0x76,0x33,0x06);
    dvi_i2c_wreg(0x76,0x34,0x26);
    dvi_i2c_wreg(0x76,0x36,0xA0);
    dvi_i2c_wreg(0x76,0x49,0xC0);
    dvi_i2c_wreg(0x76,0x21,0x09);
    if (video_type) {
        // CG3
        *aux_iic=0x00172333;
    } else {
        // TCX
        *aux_iic=0x00072333;    
    }
#ifdef NADA
    for( i=0; i<256; i++) {
        r=((i&7) <<5);
        g=(i&0x70)<<1;
        b=(i&0x80) | (i&8)<<3;
        if (i<128) g=(~g)& 0xE0;
        if ((i&15)<8) r=(~r)& 0xE0;
        set_color( i, r*65536+g*256+b );
    }
 
    for (i=0; i<16; i++) {
        for (j=0; j<16; j++) {
            k=i*16+j;
            fill_rect(k,100+i*32,100+j*32,32,32);   
        }
    }
  
    set_color( 254, 0xffffcc );

    /* BSD Colours */
    set_color( 0,0x000000); // Black
    set_color( 1,0xAA0000); // Red
    set_color( 2,0x00AA00); // Green
    set_color( 3,0xAA5500); // Brown
    set_color( 4,0x0000AA); // Blue
    set_color( 5,0xAA00AA); // Magenta
    set_color( 6,0x00AAAA); // Cyan
    set_color( 7,0x555555); // Dark gray
    set_color( 8,0xAAAAAA); // Light gray
    set_color( 9,0xFF5555); // Light red
    set_color(10,0x55FF55); // Light green
    set_color(11,0xFFFF55); // Yellow
    set_color(12,0x5555FF); // Light blue
    set_color(13,0xFF55FF); // Light magenta
    set_color(14,0x55FFFF); // Light cyan
    set_color(15,0xFFFFFF); // White
#endif
}


/* probe=1 when DVI output is connected */
int probe_dvi(void)
{
    int v;
    v=dvi_i2c_rreg(0x76,0x20);
    return (v&0x20)>>5;
}

#endif

